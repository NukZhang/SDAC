# Why SDAC

> **Why Spec‑Driven AICoding matters**  
> 为什么我们需要 SDAC（Spec‑Driven AICoding）

---

## TL;DR（一句话）

> **AI 写代码的问题，从来不是“能力不够”，而是“不受治理”。**

SDAC（Spec‑Driven AICoding）是一套把 AI 纳入工程治理体系的方法论，
用于解决 **AI Coding 在真实、长期工程中必然失控** 的问题。

---

## 1. 现实问题：为什么“直接用 AI 写代码一定会出问题”

如果你用 AI 写过稍微复杂一点、超过几天的项目，大概率已经遇到过这些情况：

- AI 会“顺手”扩展需求（哪怕你没让它这么做）
- AI 会提前设计你根本还没决定的架构
- 对话一长，AI 开始引用过期上下文
- 代码越来越多，但**工程状态越来越不清晰**
- 人类在做的事情，从“推进项目”变成了“纠正 AI”

这些问题**不是某个模型的缺陷**，而是一个结构性问题。

---

## 2. 根因：AI Coding 缺失“工程治理层”

在传统软件工程中，我们早就接受了一个事实：

- 人不是靠“聪明”写出稳定系统的
- 而是靠 **流程、约束、边界和回滚机制**

但在大多数 AI Coding 场景中，我们做的是：

```text
需求 → Prompt → AI → 代码
```

这里 **缺失了最关键的一层**：

> **治理（Governance）**

AI 被当成了“聪明的开发者”，而不是“需要被约束的执行单元”。

---

## 3. SDAC 的核心判断

SDAC 建立在三个非常现实的判断之上：

1. **AI 一定会自由发挥**（这是能力，不是 bug）
2. **长期项目一定需要状态治理**
3. **工程可控性 > 生成质量**

因此，SDAC 的目标从一开始就不是：

> “让 AI 写出更漂亮的代码”

而是：

> **“让 AI 写出的代码始终处在工程可控范围内。”**

---

## 4. SDAC 的反直觉之处

SDAC 做了几件看起来“反 AI 直觉”的事情：

- 不鼓励 AI 提建议
- 不让 AI 做架构设计
- 不让 AI 预测未来需求
- 不追求一次性最优解

取而代之的是：

- Spec 高于对话
- 约束高于智能
- 回滚优于修补
- 状态可压缩、可重写

**这并不是限制 AI，而是让 AI 能长期工作。**

---

## 5. SDAC 与“Prompt 工程”的本质区别

| Prompt 工程 | SDAC |
|---|---|
| 调教输出 | 治理行为 |
| 追求更聪明 | 追求更可控 |
| 对话驱动 | Spec 驱动 |
| 人类持续介入 | AI 自我纠偏 |
| 短期有效 | 长期可运行 |

> **Prompt 是指令，SDAC 是制度。**

---

## 6. SDAC 解决的不是“会不会写”，而是“能不能用”

在工程里，真正重要的问题从来不是：

- 这段代码是不是最优

而是：

- 能不能回滚？
- 能不能审计？
- 半年后还能不能改？

SDAC 的所有设计——

- Checklist
- 自我裁决
- Minimal Fix Diff
- AI2AI 状态压缩

都只为回答一个问题：

> **“这个 AI 的行为，是否仍然在工程可控范围内？”**

---

## 7. 谁应该使用 SDAC

SDAC 特别适合：

- 中长期个人项目
- 游戏 / Canvas / 前端复杂交互
- 多系统协作的工程
- 希望“少盯 AI，多做决策”的开发者

SDAC **不适合**：

- 一次性脚本
- 强创意型内容生成
- 完全探索性原型

---

## 8. 如果不用 SDAC，会发生什么

如果没有治理层，AI Coding 项目通常会走向两个结局之一：

1. **人类重新接管大部分决策，AI 沦为代码补全工具**
2. **项目在几轮迭代后不可维护，只能推倒重来**

SDAC 的存在，是为了提供第三条路：

> **让 AI 在工程规则下，持续、稳定、可预期地工作。**

---

## 9. 一句话总结

> **SDAC 不是为了让 AI 更聪明，
> 而是为了让 AI 在真实工程中“活得更久”。**

---

## 下一步

- 👉 查看《SDAC 白皮书》了解完整方法论
- 👉 查看架构图，理解 SDAC 的治理闭环
- 👉 在你的下一个长期项目中尝试 SDAC

---

**Spec‑Driven AICoding（SDAC）**  
Make AI Executable, Not Creative.

